class NeuralNetwork{}class NeuralNetworkBuilder{constructor(t){this.canvas=t}build(t){switch(t){case"mlp":return new MLP(this.canvas);case"cnn":return new CNN(this.canvas);case"rnn":return new RNN(this.canvas);default:return null}}}class Neuron{constructor(t,s,e,i,n,r){this.x=t,this.y=s,this.radius=e,this.active=i,this.value=n,this.hovered=r}display(t){const s=t.getContext("2d");s.beginPath(),s.fillStyle=this.active?"#FFBF02":"#239DF9",s.lineWidth=2,s.arc(this.x,this.y,this.radius,0,2*Math.PI),s.strokeStyle=this.active?"#FF7900":"#124191",s.stroke(),s.fill(),s.font=this.radius+"px Arial",s.fillStyle="#124191";const e=""===this.value?"":this.value[0];s.fillText(e,this.x-this.radius/3,this.y+this.radius/4)}activate(){this.active=!0}disable(){this.active=!1}collision(t,s){const e=t-this.x,i=s-this.y;return e*e/(this.radius*this.radius)+i*i/(this.radius*this.radius)<=1}}var Orientation;!function(t){t.HORIZONTAL="Horizontal",t.VERTICAL="Vertical"}(Orientation||(Orientation={}));class Point{constructor(t,s){this.x=t,this.y=s}}class Quadrilateral{constructor(t,s,e,i){this.p1=t,this.p2=s,this.p3=i,this.p4=e}display(t){const s=t.getContext("2d");s.beginPath(),s.lineWidth=1,s.moveTo(this.p1.x,this.p1.y),s.lineTo(this.p2.x,this.p2.y),s.lineTo(this.p3.x,this.p3.y),s.lineTo(this.p4.x,this.p4.y),s.lineTo(this.p1.x,this.p1.y),s.strokeStyle="#124191",s.stroke(),s.fillStyle="#239DF9",s.fill()}}class CNN extends NeuralNetwork{constructor(t){super(),this.canvas=t,this.layers=new Array,this.error=""}init(){this.initLayers(this.canvas),this.createConnectors()}draw(){const t=this.canvas.getContext("2d");t.save(),t.clearRect(0,0,this.canvas.width,this.canvas.height),this.display()}display(){for(let t=this.layers.length-1;t>0;t--){this.layers[t].display(this.canvas);for(let s=0;s<this.layers[t].connectors.length;s++)this.layers[t].connectors[s].display(this.canvas)}this.layers[0].display(this.canvas)}addLayer(t,s,e){try{const i=new CNN_Layer(t,s,e);this.layers.push(i),this.init()}catch(t){this.error="Error: can't add an empty layer"}}define(t){for(let s=0;s<t.length;s++)this.addLayer(t[s][0],t[s][1],t[s][2])}createConnectors(){for(let t=1;t<this.layers.length;t++)this.layers[t].createConnectors()}initLayers(t){for(let s=0;s<this.layers.length;s++)if(s>0&&(this.layers[s].parentLayer=this.layers[s-1],1===this.layers[s].parentLayer.size_y?this.layers[s].y=this.layers[s].parentLayer.y+this.layers[s].parentLayer.height+150:this.layers[s].y=this.layers[s].parentLayer.y+this.layers[s].parentLayer.height+60),this.layers[s].contracted)this.layers[s].pos_x=300,this.layers[s].pos_y=this.layers[s].y,this.layers[s].width=350,this.layers[s].height=150;else{for(let e=0;e<this.layers[s].size_y;e++){this.layers[s].neurons.push(new Array);for(let i=0;i<this.layers[s].size_x;i++){const n=20,r=1,h=this.layers[s].contracted?n:this.layers[s].size_x,a=t.width;let o=4,l=this.layers[s].isLeaf?a/(2.5*this.layers[s].size_x):a/(5*this.layers[s].size_x);const y=a-h*(2*(l=(l=l>n?n:l)<r?r:l)+o),c=this.layers[s].isLeaf?2.2:1.5;this.layers[s].neurons[e].push(new Neuron(y/2+l+i*l*c+o+e*(l/4),this.layers[s].y+l/2*e,l,!1,"")),o+=4}}this.layers[s].pos_x=this.layers[s].neurons[0][0].x,this.layers[s].pos_y=this.layers[s].neurons[0][0].y,this.layers[s].width=this.layers[s].neurons[this.layers[s].size_y-1][this.layers[s].size_x-1].x-this.layers[s].pos_x,this.layers[s].height=this.layers[s].neurons[this.layers[s].size_y-1][this.layers[s].size_x-1].y-this.layers[s].pos_y}this.layers[0].isRoot=!0}getNbNeurons(){let t=0;for(let s=0;s<this.layers.length;s++)t+=this.layers[s].getNbNeurons();return t}getNbLayers(){return this.layers.length}isContracted(){for(let t=0;t<this.layers.length;t++)if(this.layers[t].contracted)return!0;return!1}getError(){return this.error}}class CNN_Layer{constructor(t,s,e){this.size_x=t,this.size_y=null==s?1:s,this.nbChannels=null==e?0:e,this.isLeaf=1===this.size_y&&0===this.nbChannels,this.contracted=this.size_x>60||this.size_y>60,this.parentLayer=null,this.neurons=new Array,this.y=100,this.connectors=new Array}createConnectors(){if(0===this.connectors.length)if(this.connectors=Array(),this.size_y>1||this.parentLayer.size_y>1)for(let t=0;t<3;t++)for(let s=0;s<3;s++)this.connectors.push(new ConnectorSimple(new Point(this.pos_x+this.width/2,this.pos_y+this.height/2),new Point(this.parentLayer.pos_x+this.parentLayer.width/2-this.parentLayer.width/4+this.parentLayer.width/4*t,this.parentLayer.y+this.parentLayer.height/2-this.parentLayer.height/4+this.parentLayer.height/4*s)));else if(this.parentLayer.getNbNeurons()>25||this.getNbNeurons()>25)for(let t=0;t<11;t++)for(let s=0;s<11;s++)this.connectors.push(new ConnectorSimple(new Point(50+95*t,this.getY()-this.getRadius()-5),new Point(50+95*s,this.parentLayer.getY()-this.parentLayer.getRadius()+35)));else for(let t=0;t<this.parentLayer.getNbNeurons();t++)for(let s=0;s<this.getNbNeurons();s++)this.connectors.push(new ConnectorSimple(new Point(this.neurons[0][s].x,this.getY()-this.getRadius()),new Point(this.parentLayer.neurons[0][t].x,this.parentLayer.getY()+this.parentLayer.getRadius())))}display(t){const s=t.getContext("2d");if(this.contracted){new Quadrilateral(new Point(this.pos_x,this.pos_y),new Point(this.pos_x+this.width,this.pos_y),new Point(this.pos_x+60,this.pos_y+this.height),new Point(this.pos_x+this.width+60,this.pos_y+this.height)).display(t)}else for(let s=0;s<this.size_y;s++)for(let e=0;e<this.size_x;e++)this.neurons[s][e].display(t);if(!this.isLeaf){s.font="20px Arial",s.fillStyle="#124191";let t=this.size_x+" x "+this.size_y;s.fillText(t,this.pos_x-100,this.pos_y+30),s.font="30px Arial",s.fillStyle="#124191",t="X "+this.nbChannels,s.fillText(t,this.pos_x+this.width+50,this.pos_y+this.height/2)}}getNbNeurons(){return this.size_x*this.size_y}getX(){return this.neurons[0][0].x}getY(){return this.neurons[0][0].y}getRadius(){return this.neurons[0][0].radius}setRadius(t){for(let s=0;s<this.size_y;s++)for(let e=0;e<this.size_x;e++)this.neurons[s][e].radius=t}}class Connector{constructor(t,s){this.p1=t,this.p2=s}display(t){}}class ConnectorArrow extends Connector{constructor(t,s){super(t,s)}display(t){const s=t.getContext("2d");s.beginPath();const e=Math.atan2(this.p2.y-this.p1.y,this.p2.x-this.p1.x);s.save(),s.moveTo(this.p1.x,this.p1.y),s.lineTo(this.p2.x,this.p2.y),s.lineTo(this.p2.x-10*Math.cos(e-Math.PI/6),this.p2.y-10*Math.sin(e-Math.PI/6)),s.moveTo(this.p2.x,this.p2.y),s.lineTo(this.p2.x-10*Math.cos(e+Math.PI/6),this.p2.y-10*Math.sin(e+Math.PI/6)),s.stroke(),s.restore()}}class ConnectorArrowDash extends Connector{constructor(t,s){super(t,s)}display(t){const s=t.getContext("2d");s.save(),s.beginPath();const e=Math.atan2(this.p2.y-this.p1.y,this.p2.x-this.p1.x);s.setLineDash([5,15]),s.moveTo(this.p1.x,this.p1.y),s.lineTo(this.p2.x,this.p2.y),s.stroke(),s.restore(),s.save(),s.beginPath(),s.moveTo(this.p2.x,this.p2.y),s.lineTo(this.p2.x-10*Math.cos(e-Math.PI/6),this.p2.y-10*Math.sin(e-Math.PI/6)),s.moveTo(this.p2.x,this.p2.y),s.lineTo(this.p2.x-10*Math.cos(e+Math.PI/6),this.p2.y-10*Math.sin(e+Math.PI/6)),s.stroke(),s.restore()}}class ConnectorSimple extends Connector{constructor(t,s){super(t,s)}display(t){const s=t.getContext("2d");s.save(),s.beginPath(),s.lineWidth=1,s.moveTo(this.p1.x,this.p1.y),s.lineTo(this.p2.x,this.p2.y),s.strokeStyle="#000000",s.stroke(),s.restore()}}class MLP extends NeuralNetwork{constructor(t){super(),this.canvas=t,this.layers=new Array,this.error=""}init(){this.initLayers(this.canvas),this.balanceRadius(),this.createConnectors()}addLayer(t){try{const s=new MLP_Layer(t);this.layers.push(s),this.init()}catch(t){this.error="Error: can't add an empty layer"}}define(t){for(let s=0;s<t.length;s++)this.addLayer(t[s])}draw(){const t=this.canvas.getContext("2d");t.save(),t.clearRect(0,0,this.canvas.width,this.canvas.height),this.display()}initLayers(t){for(let s=0;s<this.layers.length;s++)if(0===this.layers[s].neurons.length){s>0&&(this.layers[s].parentLayer=this.layers[s-1],this.layers[s].y=this.layers[s].parentLayer.y+150);const e=30,i=1,n=this.layers[s].contracted?e:this.layers[s].size,r=t.width;let h=4,a=r/(2*n)-h/2-1;const o=r-n*(2*(a=(a=a>e?e:a)<i?i:a)+h);if(this.layers[s].contracted){for(let t=0;t<4;t++)this.layers[s].neurons.push(new Neuron(o/2+a+t*a*2+h,this.layers[s].y,a,!1,"")),h+=8;for(let t=0;t<4;t++)this.layers[s].neurons.push(new Neuron(r-o/2-a-t*a*2-h+40,this.layers[s].y,a,!1,"")),h+=8}else for(let t=0;t<n;t++)this.layers[s].neurons.push(new Neuron(o/2+a+t*a*2+h,this.layers[s].y,a,!1,"")),h+=4}}balanceRadius(){let t=this.layers[0].getRadius();for(let s=1;s<this.layers.length;s++)t>this.layers[s].getRadius()&&(t=this.layers[s].getRadius());for(let s=0;s<this.layers.length;s++)this.layers[s].setRadius(t)}createConnectors(){for(let t=1;t<this.layers.length;t++)this.layers[t].createConnectors()}display(){for(let t=1;t<this.layers.length;t++)for(let s=0;s<this.layers[t].connectors.length;s++)this.layers[t].connectors[s].display(this.canvas);for(let t=0;t<this.layers.length;t++)this.layers[t].display(this.canvas)}getNbNeurons(){let t=0;for(let s=0;s<this.layers.length;s++)t+=this.layers[s].getNbNeurons();return t}activateLayerNextNeuron(t){return t%=this.layers.length,this.layers[t].activateNextNeuron()}activateLayerNeuron(t,s){t%=this.layers.length,this.layers[t].activateNeuron(s)}activateOutputNeuron(t){this.layers[this.layers.length-1].activateNeuron(t)}disableLayer(t){t%=this.layers.length,this.layers[t].disable()}getNbLayers(){return this.layers.length}isContracted(){for(let t=0;t<this.layers.length;t++)if(this.layers[t].contracted)return!0;return!1}getError(){return this.error}}class MLP_Layer{constructor(t){this.size=t,this.contracted=this.size>60,this.parentLayer=null,this.neurons=new Array,this.y=100,this.connectors=new Array}getRadius(){return this.neurons[0].radius}setRadius(t){for(let s=0;s<this.neurons.length;s++)this.neurons[s].radius=t}getX(){return this.neurons[0].x}getY(){return this.neurons[0].y}getNbNeurons(){return this.size}display(t){const s=t.getContext("2d");if(this.contracted){const e=t.width;for(let s=0;s<this.neurons.length;s++)this.neurons[s].display(t);s.font="30px Arial";const i=". . . . . "+this.size+" neurons . . . . .";s.fillText(i,e/2-6*i.length,this.getY()+this.getRadius()/2)}else for(let s=0;s<this.size;s++)this.neurons[s].display(t)}createConnectors(){if(0===this.connectors.length)if(this.contracted||this.parentLayer.contracted)for(let t=0;t<11;t++)for(let s=0;s<11;s++)this.connectors.push(new ConnectorSimple(new Point(50+101*t,this.getY()-this.getRadius()-5),new Point(50+101*s,this.parentLayer.getY()-this.parentLayer.getRadius()+35)));else{this.connectors=Array();for(let t=0;t<this.parentLayer.size;t++)for(let s=0;s<this.size;s++)this.connectors.push(new ConnectorSimple(new Point(this.neurons[s].x,this.getY()-this.getRadius()),new Point(this.parentLayer.neurons[t].x,this.parentLayer.getY()+this.parentLayer.getRadius())))}}activateNextNeuron(){if(!this.contracted){let t=-1,s=0,e=!1;for(;s<this.neurons.length&&!e;)this.neurons[s].active&&(t=s,e=!0),s++;return-1===t?(this.neurons[0].activate(),!0):(this.neurons[t].disable(),t===this.neurons.length-1?(this.neurons[0].activate(),!1):(this.neurons[t+1].activate(),!0))}return!0}activateNeuron(t){t%=this.neurons.length;for(let t=0;t<this.neurons.length;t++)this.neurons[t].disable();this.neurons[t].activate()}disable(){for(let t=0;t<this.neurons.length;t++)this.neurons[t].disable()}}class RNN extends NeuralNetwork{constructor(t){super(),this.canvas=t,this.steps=new Array,this.layers=new Array,this.orientation=Orientation.HORIZONTAL,this.error=""}init(){this.initLayers(this.canvas),this.createConnectors()}addLayer(t){try{const s=new RNN_Layer(t);this.layers.push(s)}catch(t){this.error="Error: can't add an empty layer"}}define(t,s,e,i){this.nbLayers=s+2,this.contracted=t>15,this.nbSteps=this.isContracted()?15:t;for(let t=0;t<this.nbLayers;t++)this.addLayer(3);switch(i.toLowerCase()){case"horizontal":this.orientation=Orientation.HORIZONTAL;break;case"vertical":this.orientation=Orientation.VERTICAL}this.init(),this.serie=e}draw(){const t=this.canvas.getContext("2d");t.save(),t.clearRect(0,0,this.canvas.width,this.canvas.height),this.display()}initLayers(t){let s=54;const e=this.nbSteps,i=t.width;let n=i/(2*e)-s/2-1;const r=i-e*(2*(n=(n=n>30?30:n)<1?1:n)+s);for(let t=0;t<this.nbSteps;t++){for(let e=0;e<this.layers.length;e++)if(0===this.layers[e].neurons.length){e>0&&(this.layers[e].parentLayer=this.layers[e-1],this.layers[e].y=this.layers[e].parentLayer.y+120);let i=0;for(let h=0;h<this.layers[e].size;h++){switch(this.orientation){case Orientation.HORIZONTAL:this.layers[e].neurons.push(new Neuron(r/2+n+t*n*2+s-30,this.layers[e].y+i,n,!1,""));break;case Orientation.VERTICAL:this.layers[e].neurons.push(new Neuron(this.layers[e].y,r/2+n+t*n*2+s+i-30,n,!1,""))}i+=n/3}}s+=54,this.steps.push(this.layers),this.layers=new Array;for(let t=0;t<this.nbLayers;t++)this.addLayer(3)}}createConnectors(){for(let t=0;t<this.nbSteps;t++)for(let s=0;s<this.layers.length;s++)this.steps[t][s].createConnectors(t,s,this)}displaySteps(){for(let t=0;t<this.nbSteps;t++)for(let s=0;s<this.layers.length;s++)this.steps[t][s].display(this.canvas,this)}display(){const t=this.canvas.getContext("2d");for(let t=0;t<this.nbSteps;t++)for(let s=0;s<this.steps[t].length;s++)for(let e=0;e<this.steps[t][s].connectors.length;e++)this.steps[t][s].connectors[e].display(this.canvas);if(this.displaySteps(),null!=this.serie)if(this.nbSteps+1===this.serie.length)switch(this.orientation){case Orientation.HORIZONTAL:for(let s=0;s<this.nbSteps;s++)t.font="30px Arial",t.fillText(this.serie[s],this.steps[s][0].neurons[0].x-10,this.steps[s][0].neurons[0].y-40),t.fillText("t="+s,this.steps[s][0].neurons[0].x-20,this.steps[s][0].neurons[0].y-90);for(let s=1;s<=this.nbSteps;s++)t.font="30px Arial",t.fillText(this.serie[s],this.steps[s-1][0].neurons[0].x-10,this.steps[s-1][this.nbLayers-1].neurons[0].y+80);break;case Orientation.VERTICAL:for(let s=0;s<this.nbSteps;s++){t.font="30px Arial";const e=this.steps[s][0].neurons[this.steps[s][0].neurons.length-1];t.fillText(this.serie[s],e.x-60,e.y),t.fillText("t="+s,e.x-120,e.y)}for(let s=1;s<=this.nbSteps;s++){t.font="30px Arial";const e=this.steps[s-1][this.nbLayers-1].neurons[this.steps[s-1][this.nbLayers-1].neurons.length-1];t.fillText(this.serie[s],e.x+60,e.y)}}else this.isContracted()?console.error("Can't display serie data in a contracted view (serie length > 15)"):console.error("The (nb steps+1) and the serie length must be equal")}getNbNeurons(){let t=0;for(let s=0;s<this.layers.length;s++)t+=this.layers[s].getNbNeurons();return t}activateLayerNeuron(t,s){t%=this.layers.length,this.layers[t].activateNeuron(s)}activateOutputNeuron(t){this.layers[this.layers.length-1].activateNeuron(t)}disableLayer(t){t%=this.layers.length,this.layers[t].disable()}getNbLayers(){return this.layers.length}isContracted(){return this.contracted}getError(){return this.error}}class RNN_Layer{constructor(t){this.size=t,this.parentLayer=null,this.neurons=new Array,this.y=150,this.connectors=new Array}getRadius(){return this.neurons[0].radius}setRadius(t){for(let s=0;s<this.neurons.length;s++)this.neurons[s].radius=t}getX(){return this.neurons[0].x}getY(){return this.neurons[0].y}getNbNeurons(){return this.size}display(t,s){for(let s=0;s<this.size;s++)this.neurons[s].display(t)}createConnectors(t,s,e){if(0===this.connectors.length){if(s>0)switch(e.orientation){case Orientation.HORIZONTAL:if(this.connectors.push(new ConnectorArrow(new Point(this.parentLayer.neurons[this.parentLayer.neurons.length-1].x,this.parentLayer.neurons[this.parentLayer.neurons.length-1].y+this.parentLayer.getRadius()),new Point(this.neurons[0].x,this.getY()-this.getRadius()))),s<e.nbLayers-1&&t<e.nbSteps-1){const i=e.steps[t+1][s];this.connectors.push(new ConnectorArrow(new Point(this.neurons[this.neurons.length-1].x+this.getRadius(),this.neurons[this.neurons.length-1].y),new Point(i.neurons[i.neurons.length-1].x-this.getRadius(),i.neurons[i.neurons.length-1].y)))}break;case Orientation.VERTICAL:if(this.connectors.push(new ConnectorArrow(new Point(this.parentLayer.neurons[this.parentLayer.neurons.length-1].x+this.parentLayer.getRadius(),this.parentLayer.neurons[this.parentLayer.neurons.length-1].y),new Point(this.neurons[this.neurons.length-1].x-this.getRadius(),this.neurons[this.neurons.length-1].y))),t<e.nbSteps-1&&s<e.nbLayers-1){const i=e.steps[t+1][s];this.connectors.push(new ConnectorArrow(new Point(this.neurons[0].x,this.neurons[0].y+this.getRadius()),new Point(i.neurons[0].x,i.neurons[0].y-i.getRadius())))}}if(s===e.nbLayers-1&&t<e.nbSteps-1){const i=e.steps[t][s],n=e.steps[t+1][0];switch(e.orientation){case Orientation.HORIZONTAL:this.connectors.push(new ConnectorArrowDash(new Point(i.neurons[0].x+i.getRadius()/3,i.getY()-i.getRadius()),new Point(n.neurons[n.neurons.length-1].x-n.getRadius()/3,n.neurons[n.neurons.length-1].y+n.getRadius())));break;case Orientation.VERTICAL:this.connectors.push(new ConnectorArrowDash(new Point(i.neurons[0].x-i.getRadius(),i.getY()+i.getRadius()),new Point(n.neurons[n.neurons.length-1].x+n.getRadius(),n.neurons[n.neurons.length-1].y-n.getRadius())))}}}}activateNeuron(t){t%=this.neurons.length;for(let t=0;t<this.neurons.length;t++)this.neurons[t].disable();this.neurons[t].activate()}disable(){for(let t=0;t<this.neurons.length;t++)this.neurons[t].disable()}}
